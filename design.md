lisping 语言设计
===

lisping 是一个采用 clojure 语法, 静态类型, 支持命令式编程的语言,
并考虑吸收其他语言的一些优点.
>以后可能考虑支持中缀表达式, 但一开始为了简单起见, 只考虑前缀表达式.

## 数据就是程序

数据就是程序, 执行程序就是对表达式求值.
表达式用语法树表示,

程序的执行过程就是对语法树进行深度优先遍历并求值.
对表达式求值叫做 `eval`.
eval 需要访问上下文的符号表,
可以定义为 Form，或者支持传入上下文的函数.

eval 语义如下:

* 原子元素, 求值完即结束
* 复合表达式
	* 非 list 表达式, 递归求值所有元素
	* list 表达式
		* 基本操作, 将 list 语法树传递给基本操作命令执行
		* 函数, 递归求值所有子表达式后调用函数

对 list 表达式求值时发生操作调用.
操作分为:

0. 语言内置的基本操作, Form. 如变量定义, 结构控制.
0. 函数, Fn. 包括用户定义函数, 所有 java 函数. 
java 类名可看作产生 java 对象的函数.
0. 以后可能考虑支持宏. 宏较复杂, 赞不考虑.

数据是可以运行时产生的.
如果支持运行时执行 eval 操作, 
即支持运行时构造一段程序并执行新构造的程序,
那么这个语言就必然支持解释执行.
读入源码只是构造程序的一种快速方便形式,
解释器就是读入程序, 然后立即执行.

## 字节码编译器

编译过程就是读入表达式, 即读入数据,
执行静态检查, 然后将数据保存为运行时更友好的数据格式,
比如更方便读入, 假设已经执行过静态检查, 因此可能省略静态检查等.
编译时还可能做一些优化, 比如将一些表达式重写为更简单的几条指令.
优化后表达式结构将不存在, 也不能调试, 
所以调式时应该禁用优化, 或者执行未优化的代码.

## 转换型编译器

转换型编译器将程序转换成可在另一种解释器上执行的程序,
这样就不需要实现解释器.
如转换成 scala 代码, 或者 java 字节码.

如果目标解释器不支持等价的 eval 语义,
就需要在编译时将 eval 语义转换成等价的目标代码.
因为编译时只能翻译代码, 不能得到 eval 后的结果,
所以语言本身就不能支持 eval 语义.
翻译 + 解释执行才能等于运行时的 eval.

## 解释器

读入数据, 即表达式语法树, 然后对语法树求值.
关键就是这个求值函数,
可以认为解释器就是一个运行时的 eval 函数.

解释器最终也会运行在一个目标解释器上, OS 也可看作一个 native 解释器.
要实现 eval 语义, 就必须在目标解释器上实现一个等价的 eval 函数.

>python 支持类似的 eval 语义, 或者可以考虑 python 平台?

## 语言定义

语言支持调用目标解释器的函数,
支持 clojure 的基本控制结构.

简单 "hello world" 程序示例如下:

```clj
(java.lang.System.out.println "hello")
```

* 变量定义 `(var <name> <value> [type])`

## 简单翻译型编译器 lisping-simple

最初的实现, 可以只是简单把程序翻译成 scala 源码,
然后用 scala 解释器执行.
可以考虑在 jvm 内使用 `scala.tools.nsc.MainGenericRunner` 类执行.

如果目标解释器不支持等价的 eval 语义,
就需要在编译时将 eval 语义转换成等价的目标代码.

如下 "hello.clj" 可翻译为 "hello.scala".

hello.clj:

```clj
(var x "hello")
(println x)
```

hello.scala:

```scala
var x = "hello"
println(x)
```

